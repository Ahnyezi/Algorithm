# 합분해
# 방법
# 표로 하나씩 그려본다
# 각 시행의 개수를 써넣는다
# 규칙을 찾는다.

# 찾은 규칙
# 예를 들어, 4개의 정수로 3을 만든다고 하자.
# 방법은 쉽게 다음과 같이 나눌 수 있다.
# 1) 1개로 0을 만드는 경우 * 3개로 3을 만드는 경우
# 2) 1개로 1을 만드는 경우 * 3개로 2를 만드는 경우
# 3) 1개로 2를 만드는 경우 * 3개로 1을 만드는 경우
# 4) 1개로 3을 만드는 경우 * 3개로 0을 만드는 경우
# [check] 2개로 0을 만들고, 2개로 3을 만드는 경우는 앞의 시행에 포함되므로 고려하지 않아도 된다.
# ex) [1]에서 0 / 003 [check]에서 00 /03 같다. 즉, 1~4번에 모든 경우가 포함된다.
# 즉, 4개의 정수로 3을 만드는 경우를 dp[4][3]이라고 보았을 때,
# dp[4][3] =
# dp[1][0] + dp[3][3] +
# dp[1][1] * dp[3][2] +
# dp[1][2] * dp[3][1] +
# dp[1][3] * dp[3][0]
# 1개의 정수로 n을 만드는 dp[1] 행의 모든 값은 1이되기 때문에
# 이를 고려하여 다시 정리하면
# dp[4][3] = dp[3][3] + dp[3][2] + dp[3][1] + dp[3][0] 이 된다.
# 즉, dp[4][3] 은 dp[4-1][0] ~ dp[4-1][4-1]까지의 원소를 더한 값이 된다.

# 이것으로 일반항을 세워보자.
# dp[i][j] = dp[i-1][0] + dp[i-1][1] + ... + dp[i-1][j-1] + dp[i-1][j]
# 이 때, dp[i][j-1] 이 dp[i-1][0] 부터 dp[i-1][j-1]이 되므로
# 다시 정리하면
# dp[i][j] = dp[i][j-1] + dp[i-1][j]이다
# 이 식을 다시 일차원 점화식으로 바꿔보자.
#

# 2차원 dp로 풀기
# import sys
# input = sys.stdin.readline
# n,k = map(int,input().split())
# mod = 1000000000
# dp = [[0 for _ in range(n+1)] for _ in range(k+1)]
#
# for i in range(1,k+1):
#     dp[i][0] = 1
#     for j in range(1,n+1):
#         dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % mod
#
# print(dp[-1][-1])

# 1차원 dp로 풀기
import sys
input = sys.stdin.readline
n,k = map(int,input().split())
mod = 1000000000
dp = [1] + [0 for _ in range(n)]

for _ in range(k):
    for i in range(1,n+1):
        dp[i] = (dp[i-1] + dp[i]) % mod

print(dp[-1])

# 첫번째 시행 (k가 1일 때, n이 되는 경우의 수)
# dp = [1,0,0,0,0...]
# dp = [1,1,0,0,0...]
# dp = [1,1,1,0,0...]
# dp = [1,1,1,1,0...]
# 두번째 시행 (k가 2일 때, n이 되는 경우의 수)
# dp = [1,1,1,1,1,...]
# dp = [1,2,1,1,1,...]
# dp = [1,2,3,1,1,...]
# dp = [1,2,3,4,1,...]
# 세번째 시행 (k가 3일 때, n이 되는 경우의 수)
# dp = [1,2,3,4,5,...]
# dp = [1,3,6,10,15,...]
# dp = [1,4,10,20,35,...]
# dp = [1,5,15,35,70,...]
