# 백준 2225 | 합분해

<br>

[문제 링크](https://www.acmicpc.net/problem/2225)

<br>

:bulb: **풀이**<br>

**4개의 정수로 숫자 3을 만드는 경우를 생각해보자.**<br>
방법은 다음과 같이 나눌 수 있다.<br>

1) 숫자 1개로 `0`을 만드는 경우의 수 * 숫자 3개로 `3`을 만드는 경우의 수
- (예) `0` / `1 1 1`
2) 숫자 1개로 `1`을 만드는 경우의 수 * 숫자 3개로 `2`을 만드는 경우의 수
- (예) `1` / `1 1 0`
3) 숫자 1개로 `2`을 만드는 경우의 수 * 숫자 3개로 `1`을 만드는 경우의 수
- (예) `2` / `1 0 0`
4) 숫자 1개로 `3`을 만드는 경우의 수 * 숫자 3개로 `0`을 만드는 경우의 수
- (예) `3` / `0 0 0`

**주의**<br>
숫자 2개로 `0`을 만들고, 숫자 2개로 `3`을 만드는 등의 추가적인 경우를 생각할 수 있다. <br>
하지만, 이런 경우들은 모두 1~4까지의 시행에 포함되기 때문에 고려하지 않아도 된다. <br>
- (예) 2개로 0을 만들고, 2개로 3을 만드는 경우에 해당하는 `00`/`03`은
- 시행1에서 `0`/`003`으로 표현되기 때문에 이미 경우에 포함된다. 
<br>

즉, 4개의 정수로 숫자 3을 만드는 경우를 `dp[4][3]`이라고 하면 다음과 같이 표현된다. <br>

```python
dp[4][3] = dp[1][0] + dp[3][3] +
	dp[1][1] * dp[3][2] +	
	dp[1][2] * dp[3][1] +
	dp[1][3] * dp[3][0]
```

이 때, 1개의 정수로 n을 만드는`dp[1]` 행의 모든 값은 `1`이 되기 때문에, <br>
이를 고려하여 `dp[4][3]`을 다시 정리하면 다음과 같이 표현된다. <br>

<img src="https://user-images.githubusercontent.com/62331803/100301586-c71f6980-2fdb-11eb-9514-acad70468de1.png" width="50%">
<br>

```python
dp[4][3] = dp[3][3] +
	dp[3][2] +	
	dp[3][1] +
	dp[3][0]
```

이것으로 점화식을 세워보면 다음과 같이 표현된다. <br>
`dp[i][j] = dp[i-1][0] + dp[i-1][1] + ... + dp[i-1][j-1] + dp[i-1][j]` <br>

<br>

이 때 점화식의 원리에 의해  `dp[i-1][0] + dp[i-1][1] + ... + dp[i-1][j-1]`는 `dp[i][j-1]`이 되므로<br>
`dp[i][j] = dp[i][j-1] + dp[i-1][j]`라는 간단한 식을 도출할 수 있다. <br>

> `dp[3][0] + ... + dp[3][3] == dp[4][3]` <br>

<img src="https://user-images.githubusercontent.com/62331803/100301890-84aa5c80-2fdc-11eb-8345-e6565b2f114c.png" width="50%">
<br>

<img src="https://user-images.githubusercontent.com/62331803/100301897-883de380-2fdc-11eb-977f-ee12ce775f34.png" width="50%">
<br>

따라서, `dp[4][3] = dp[4][2] + dp[3][3]`

# 풀이
## 2차원 dp로 풀기

```python
import sys
input = sys.stdin.readline
n,k = map(int,input().split())
mod = 1000000000
dp = [[0 for _ in range(n+1)] for _ in range(k+1)]

for i in range(1,k+1):
    dp[i][0] = 1
    for j in range(1,n+1):
        dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % mod

print(dp[-1][-1])
```


## 1차원 dp로 풀기

```python
import sys
input = sys.stdin.readline
n,k = map(int,input().split())
mod = 1000000000
dp = [1] + [0 for _ in range(n)]

for _ in range(k):
    for i in range(1,n+1):
        dp[i] = (dp[i-1] + dp[i]) % mod

print(dp[-1])

# 첫번째 시행 (k가 1일 때, n이 되는 경우의 수)
dp = [1,0,0,0,0...]
dp = [1,1,0,0,0...]
dp = [1,1,1,0,0...]
dp = [1,1,1,1,0...]
# 두번째 시행 (k가 2일 때, n이 되는 경우의 수)
dp = [1,1,1,1,1,...]
dp = [1,2,1,1,1,...]
dp = [1,2,3,1,1,...]
dp = [1,2,3,4,1,...]
# 세번째 시행 (k가 3일 때, n이 되는 경우의 수)
dp = [1,2,3,4,5,...]
dp = [1,3,6,10,15,...]
dp = [1,4,10,20,35,...]
dp = [1,5,15,35,70,...]
.
.

```



 