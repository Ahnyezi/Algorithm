# 다이나믹프로그래밍

### 타일링
- B11726 | 
- B11727 | 
- B2133 | 


### 20201006 (화)
- B1463 | 1로 만들기 (못풂) ☆☆☆
  - 큰 수로 나누는 것이 능사 아니다.
  - 모든 경우의 수 다 구해서 최소값으로 초기화
- B9095 | 1,2,3 더하기 (못풂) ☆☆☆
  - 문제 제대로 보기! 
      - 1,2,3 만 연산 가능
      - 테스트 케이스 개수가 미리 주어짐
  - 주의: 일반적 케이스 이외에 n이 1이거나 2일 때도 고려하기! ==> d[3] 존재하지 않음 if문으로 처리


### 20201007 (수)
- B1003 | 피보나치 수열 (맞음) ☆
   - 경우의 수 하나씩 써가면서 점화식 생각하기
- B2579 | 계단오르기 (못풂) ☆☆☆☆
   - 조건 추가된 경우에도 점화식 세우는데 집중
   - 기본항 주의
   - N==1일경우 주의


### 20201009 (금)
- B1932 | 정수삼각형 (못풂) ☆☆☆
   - dp는 모든 경우의 수를 고려하는 문제
      - 그리디처럼 풀면 놓치는 case 생김
  - 주어진 square 자체가 2차원 dp 배열이 되게끔 하기
- B2193 | 이친수(못풂) ☆☆
   - 점화식 세우는 방법 : 직접 나열해서 규칙을 찾기
      - 나열하면 쉽게 풀 수 있는 방법 찾을 수 있음


### 20201010 (토)
- B2156 | 포도주 시식 (틀림) ☆☆
   - dp[n]을 구할 때 dp[n-1] 고려대상인지 아닌지 확인하기!
   - 오답: `dp[i] = max(dp[i-3]+w[i-1],dp[i-2])+w[i]`
   - 정답: `dp[i] = max(dp[i-1],dp[i-3]+w[i-1]+w[i],dp[i-2]+w[i])`
- B1912 | 연속합 (맞음) ☆☆
   - 수열의 모든 항 음수일 경우, max 값 0으로 나오는 것 잡아주기


### 20201014 (수)
- B11053 | 가장 긴 증가하는 부분 수열 (틀림) ☆☆
   - 배열 안의 모든 값들과 비교해야 함. 바로 전 시행에 사용된 값만 비교하는 것이 아님
   - 알고리즘 구성 방법 :: 자기보다 작은 수이면서, 최대길이인 항을 찾고 +1
   - 길이에 따라서 최댓값 다르기 때문에 출력에 max함수 사용
- B2293 | 동전1 (못풂) ☆☆☆☆
    - coins 배열의 모든 값에 대하여, 현재 동전으로 k원을 만들 수 있는 경우의 수를 dp[k]에 저장
    - coins의 모든 동전을 순회하면서 dp[k]값을 더해나감
    - dp[k] = dp[k](기존의 동전을 사용하여 구한 경우의 수) + dp[k-c](현재 동전의 가치를 뺀 가치를 구하는 경우의 수)