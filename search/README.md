# 탐색 알고리즘

> 너비 우선 탐색
- 너비를 우선으로 하여 탐색을 수행
- '최단 경로'를 찾아주기 때문에, 최단 길이 보장에 사용
- queue로 구현

> 깊이 우선 탐색
- 보다 깊은 것을 우선적으로 탐색
- 너비 우선 : queue, 깊이 우선 : stack
- 하지만, stack 사용하지 않아도 재귀로 구현 가능
    - 컴퓨터는 구조적으로 항상 stack의 원리를 사용
    - 따라서, stack에 담고 빼는 것과 동일한 효과를 낸다.

### 20201019 (월)
- B1260 | DFS와 BFS (못풂) ☆☆
    - print(*dfs())

### 20201020 (화)
- B1926 | 그림 (못풂) ☆☆
    - queue 사용법 : `queue = deque([[i, j]]) `

### 20201106 (금)
- B2178 | 미로 탐색 ☆☆
   - 이차원배열에서 N과 M의 위치 주의!!

### 20201108 (일)
- B1012 | 유기농 배추 ☆☆
   - 왜 시간초과가 나능거니 ^^
- B7569 | 토마토 ☆☆☆
    - 아이디어 : 3차원 => 6
    - queue에 모두 삽입 한 후 bfs() 호출

### 20201109 (월)
- B1697 | 숨바꼭질 ☆☆☆
    - 아이디어: 연산결과와 횟수 함께 저장
    - `queue.append([point-1,cnt+1])`
- B2667 | 단지번호 붙이기 ☆☆
    - 정렬 함수 사용법 주의
        - `arr = sorted(arr)`
        - `arr.sort()`

### 20201110 (화)
- B9466 | 텀 프로젝트 ☆☆☆☆
    - dfs

### 20201119 (목)
- B2583 | 영역 구하기 ☆☆
    - 좌표형태로 주어진 idx를 이차원 리스트에서 사용하는 idx 형태로 변환

### 20201120 (금)
- B7562 | 나이트의 이동 ☆
    - visited배열 없이 진행할 경우, 불필요한 연산 때문에 속도 매우 느림